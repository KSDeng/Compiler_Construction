!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ARRAY_INFO	semantic.h	/^struct ARRAY_INFO {    $/;"	s
ARRAY_INFO	semantic.h	/^typedef struct ARRAY_INFO ARRAY_INFO;$/;"	t	typeref:struct:ARRAY_INFO
Address_IR	intercodegen.h	/^    Address_IR,             \/\/ &$/;"	e	enum:IRType
ArgListNode	intercodegen.h	/^typedef struct ArgListNode{$/;"	s
ArgListNode	intercodegen.h	/^}ArgListNode;$/;"	t	typeref:struct:ArgListNode
Arg_IR	intercodegen.h	/^    Arg_IR,                 \/\/ parameter pass$/;"	e	enum:IRType
Args	semantic.c	/^char* Args(Node* args, char* funcName){$/;"	f
Args	syntax.y	/^Args : Exp COMMA Args       { printDebug2("Args -> Exp COMMA Args", @$.first_line);$/;"	l
Assign_IR	intercodegen.h	/^    Assign_IR,              \/\/ =$/;"	e	enum:IRType
BISON	Makefile	/^BISON = bison$/;"	m
BKDRHash	semantic.c	/^unsigned int BKDRHash(char* str){$/;"	f
Boolean	parseTree.h	/^typedef enum Boolean{$/;"	g
CC	Makefile	/^CC = gcc -w -g$/;"	m
CFILES	Makefile	/^CFILES = $(shell find .\/ -name "*.c")$/;"	m
CFLAGS	Makefile	/^CFLAGS = -std=c99$/;"	m
Call_IR	intercodegen.h	/^    Call_IR,                \/\/ call function$/;"	e	enum:IRType
CompSt	semantic.c	/^void CompSt(Node* compst, char* returnType){$/;"	f
CompSt	syntax.y	/^CompSt : LC DefList StmtList RC     { printDebug2("CompSt -> LC DefList StmtList RC", @$.first_line);  $/;"	l
ConJump_IR	intercodegen.h	/^    ConJump_IR,             \/\/ conditional jump$/;"	e	enum:IRType
Dec	semantic.c	/^void Dec(Node* dec, char* typeName){$/;"	f
Dec	syntax.y	/^Dec : VarDec        { printDebug2("Dec -> VarDec", @$.first_line); $/;"	l
DecList	semantic.c	/^void DecList(Node* declist, char* typeName){$/;"	f
DecList	syntax.y	/^DecList : Dec       { printDebug2("DecList -> Dec", @$.first_line);    $/;"	l
DecMemory_IR	intercodegen.h	/^    DecMemory_IR,           \/\/ ask for memory$/;"	e	enum:IRType
Def	semantic.c	/^void Def(Node* def){$/;"	f
Def	syntax.y	/^Def : Specifier DecList SEMI        { printDebug2("Def -> Specifier DecList SEMI", @$.first_line); $/;"	l
DefList	semantic.c	/^void DefList(Node* deflist){$/;"	f
DefList	syntax.y	/^DefList : Def DefList       { printDebug2("DefList -> Def DefList", @$.first_line);$/;"	l
Divide_IR	intercodegen.h	/^    Divide_IR,              \/\/ \/$/;"	e	enum:IRType
Exp	semantic.c	/^VAR_INFO* Exp(Node* exp){$/;"	f
Exp	syntax.y	/^Exp : Exp ASSIGNOP Exp      { printDebug2("Exp -> Exp ASSIGNOP Exp", @$.first_line);$/;"	l
ExtDecList	semantic.c	/^void ExtDecList(Node* extdeclist, char* typeName){$/;"	f
ExtDecList	syntax.y	/^ExtDecList : VarDec     { printDebug2("ExtDecList -> VarDec", @$.first_line);  $/;"	l
ExtDef	semantic.c	/^void ExtDef(Node* extdef){$/;"	f
ExtDef	syntax.y	/^ExtDef : Specifier ExtDecList SEMI  { printDebug2("ExtDef -> Specifier ExtDecList SEMI", @$.first_line);$/;"	l
ExtDefList	semantic.c	/^void ExtDefList(Node* extdeflist){$/;"	f
ExtDefList	syntax.y	/^ExtDefList : ExtDef ExtDefList  { printDebug2("ExtDefList -> ExtDef ExtDefList", @$.first_line);$/;"	l
FLEX	Makefile	/^FLEX = flex$/;"	m
FUNC_INFO	semantic.h	/^struct FUNC_INFO {$/;"	s
FUNC_INFO	semantic.h	/^typedef struct FUNC_INFO FUNC_INFO;$/;"	t	typeref:struct:FUNC_INFO
FunDec	semantic.c	/^void FunDec(Node* fundec, char* returnTypeName){$/;"	f
FunDec	syntax.y	/^FunDec : ID LP VarList RP   { printDebug2("FunDec -> ID LP VarList RP", @$.first_line);$/;"	l
Function_IR	intercodegen.h	/^    Function_IR,            \/\/ function$/;"	e	enum:IRType
Goto_IR	intercodegen.h	/^    Goto_IR,                \/\/ goto$/;"	e	enum:IRType
HASH_ELE	semantic.h	/^struct HASH_ELE {$/;"	s
HASH_ELE	semantic.h	/^typedef struct HASH_ELE HASH_ELE;$/;"	t	typeref:struct:HASH_ELE
HASH_NODE	semantic.h	/^typedef struct HASH_TABLE_NODE HASH_NODE;$/;"	t	typeref:struct:HASH_TABLE_NODE
HASH_TABLE_NODE	semantic.h	/^struct HASH_TABLE_NODE {$/;"	s
HASH_TABLE_SIZE	semantic.h	5;"	d
IRType	intercodegen.h	/^typedef enum IRType {$/;"	g
IRType	intercodegen.h	/^} IRType;$/;"	t	typeref:enum:IRType
InterCode	intercodegen.h	/^typedef struct InterCode {$/;"	s
InterCode	intercodegen.h	/^}InterCode;$/;"	t	typeref:struct:InterCode
InterCodeNode	intercodegen.h	/^typedef struct InterCodeNode{$/;"	s
InterCodeNode	intercodegen.h	/^}InterCodeNode;$/;"	t	typeref:struct:InterCodeNode
LFC	Makefile	/^LFC = $(shell find .\/ -name "*.l" | sed s\/[^\/]*\\\\.l\/lex.yy.c\/)$/;"	m
LFILE	Makefile	/^LFILE = $(shell find .\/ -name "*.l")$/;"	m
LFO	Makefile	/^LFO = $(LFC:.c=.o)$/;"	m
Label_IR	intercodegen.h	/^    Label_IR,               \/\/ label$/;"	e	enum:IRType
Minus_IR	intercodegen.h	/^    Minus_IR,               \/\/ -$/;"	e	enum:IRType
Multiply_IR	intercodegen.h	/^    Multiply_IR,            \/\/ *$/;"	e	enum:IRType
NameMap	intercodegen.h	/^typedef struct NameMap{$/;"	s
NameMap	intercodegen.h	/^}NameMap;$/;"	t	typeref:struct:NameMap
NameMapNode	intercodegen.h	/^typedef struct NameMapNode{$/;"	s
NameMapNode	intercodegen.h	/^}NameMapNode;$/;"	t	typeref:struct:NameMapNode
Node	parseTree.h	/^} Node;$/;"	t	typeref:struct:TreeNode
OBJS	Makefile	/^OBJS = $(CFILES:.c=.o)$/;"	m
Operand	intercodegen.h	/^typedef struct Operand {$/;"	s
Operand	intercodegen.h	/^}Operand;$/;"	t	typeref:struct:Operand
OptTag	semantic.c	/^char* OptTag(Node* opttag){$/;"	f
OptTag	syntax.y	/^OptTag : ID     { printDebug2("OptTag -> ID", @$.first_line);$/;"	l
ParamDec	syntax.y	/^ParamDec : Specifier VarDec     { printDebug2("ParamDec -> Specifier VarDec", @$.first_line);$/;"	l
Param_IR	intercodegen.h	/^    Param_IR,               \/\/ parameter declaration$/;"	e	enum:IRType
Plus_IR	intercodegen.h	/^    Plus_IR,                \/\/ +$/;"	e	enum:IRType
Program	semantic.c	/^void Program(Node* program){$/;"	f
Program	syntax.y	/^Program : ExtDefList        { printDebug2("Program -> ExtDefList", @$.first_line);$/;"	l
ReadMemory_IR	intercodegen.h	/^    ReadMemory_IR,          \/\/ read memory (x := *y)$/;"	e	enum:IRType
Read_IR	intercodegen.h	/^    Read_IR,                \/\/ read from console$/;"	e	enum:IRType
Return_IR	intercodegen.h	/^    Return_IR,              \/\/ return statement$/;"	e	enum:IRType
STRUCT_INFO	semantic.h	/^struct STRUCT_INFO {$/;"	s
STRUCT_INFO	semantic.h	/^typedef struct STRUCT_INFO STRUCT_INFO;$/;"	t	typeref:struct:STRUCT_INFO
SYMBOL_LIST_NODE	semantic.h	/^struct SYMBOL_LIST_NODE {$/;"	s
SYMBOL_NODE	semantic.h	/^typedef struct SYMBOL_LIST_NODE SYMBOL_NODE;$/;"	t	typeref:struct:SYMBOL_LIST_NODE
Specifier	semantic.c	/^char* Specifier(Node* specifier){$/;"	f
Specifier	syntax.y	/^Specifier : TYPE    { printDebug2("Specifier -> TYPE", @$.first_line); $/;"	l
Stmt	semantic.c	/^void Stmt(Node* stmt, char* returnType){$/;"	f
Stmt	syntax.y	/^Stmt : Exp SEMI     { printDebug2("Stmt -> Exp SEMI", @$.first_line);  $/;"	l
StmtList	semantic.c	/^void StmtList(Node* stmtlist, char* returnType){$/;"	f
StmtList	syntax.y	/^StmtList : Stmt StmtList    { printDebug2("StmtList -> Stmt StmtList", @$.first_line); $/;"	l
StructSpecifier	semantic.c	/^char* StructSpecifier(Node* structspecifier){$/;"	f
StructSpecifier	syntax.y	/^StructSpecifier : STRUCT OptTag LC DefList RC   { printDebug2("StructSpecifier -> STRUCT OptTag LC DefList RC", @$.first_line);   $/;"	l
TYPE_DETAIL	semantic.h	/^typedef union TYPE_DETAIL TYPE_DETAIL;$/;"	t	typeref:union:TYPE_DETAIL
TYPE_DETAIL	semantic.h	/^union TYPE_DETAIL {$/;"	u
TYPE_INFO	semantic.h	/^struct TYPE_INFO {$/;"	s
TYPE_INFO	semantic.h	/^typedef struct TYPE_INFO TYPE_INFO;$/;"	t	typeref:struct:TYPE_INFO
TYPE_LIST_NODE	semantic.h	/^struct TYPE_LIST_NODE {$/;"	s
TYPE_NODE	semantic.h	/^typedef struct TYPE_LIST_NODE TYPE_NODE;$/;"	t	typeref:struct:TYPE_LIST_NODE
Tag	syntax.y	/^Tag : ID    { printDebug2("Tag -> ID", @$.first_line); $/;"	l
TreeNode	parseTree.h	/^typedef struct TreeNode{$/;"	s
VAR_INFO	semantic.h	/^struct VAR_INFO {$/;"	s
VAR_INFO	semantic.h	/^typedef struct VAR_INFO VAR_INFO;$/;"	t	typeref:struct:VAR_INFO
VarDec	semantic.c	/^char* VarDec(Node* vardec, char* typeName){$/;"	f
VarDec	syntax.y	/^VarDec : ID    { printDebug2("VarDec -> ID", @$.first_line);$/;"	l
VarList	syntax.y	/^VarList : ParamDec COMMA VarList    { printDebug2("VarList -> ParamDec COMMA VarList", @$.first_line);$/;"	l
WriteMemory_IR	intercodegen.h	/^    WriteMemory_IR,         \/\/ write memory (*x := y)$/;"	e	enum:IRType
Write_IR	intercodegen.h	/^    Write_IR,               \/\/ write to console$/;"	e	enum:IRType
YFC	Makefile	/^YFC = $(shell find .\/ -name "*.y" | sed s\/[^\/]*\\\\.y\/syntax.tab.c\/)$/;"	m
YFILE	Makefile	/^YFILE = $(shell find .\/ -name "*.y")$/;"	m
YFO	Makefile	/^YFO = $(YFC:.c=.o)$/;"	m
_INTERCODEGEN_H_	intercodegen.h	2;"	d
_PARSE_TREE_H_	parseTree.h	2;"	d
_SEMANTIC_H_	semantic.h	2;"	d
argListHead	intercodegen.c	/^ArgListNode* argListHead = NULL;$/;"	v
array_info	semantic.h	/^    struct ARRAY_INFO* array_info;$/;"	m	union:TYPE_DETAIL	typeref:struct:TYPE_DETAIL::ARRAY_INFO
bool	parseTree.h	/^} bool;$/;"	t	typeref:enum:Boolean
children	parseTree.h	/^    struct TreeNode** children;        \/\/ children of current node$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode
children	semantic.h	/^    struct HASH_TABLE_NODE** children;$/;"	m	struct:HASH_TABLE_NODE	typeref:struct:HASH_TABLE_NODE::HASH_TABLE_NODE
clearArgList	intercodegen.c	/^void clearArgList(){$/;"	f
conJump	intercodegen.h	/^        }conJump;$/;"	m	union:InterCode::__anon1	typeref:struct:InterCode::__anon1::__anon5
constructTree	parseTree.c	/^void constructTree(Node* parent, int n_children, ...){$/;"	f
copyArrayInfo	semantic.c	/^ARRAY_INFO* copyArrayInfo(ARRAY_INFO* src){$/;"	f
copyFuncInfo	semantic.c	/^FUNC_INFO* copyFuncInfo(FUNC_INFO* src){$/;"	f
copyOperand	intercodegen.c	/^Operand* copyOperand(Operand* src){$/;"	f
copyStructInfo	semantic.c	/^STRUCT_INFO* copyStructInfo(STRUCT_INFO* src){$/;"	f
copyTypeInfo	semantic.c	/^TYPE_INFO* copyTypeInfo(TYPE_INFO* src, const char* typeCategory){$/;"	f
copyVarInfo	semantic.c	/^VAR_INFO* copyVarInfo(VAR_INFO* src){$/;"	f
createHashNode	semantic.c	/^HASH_NODE* createHashNode(HASH_NODE* parent){$/;"	f
createLabel	intercodegen.c	/^Operand* createLabel(){$/;"	f
createNode	parseTree.c	/^Node* createNode(char* name, char* propertyValue, int first_line){$/;"	f
createTemp	intercodegen.c	/^Operand* createTemp(){$/;"	f
debug	parseTree.c	/^bool debug = false;      \/\/ set true to enter debug mode$/;"	v
debug_intercode	intercodegen.c	/^bool debug_intercode = true;$/;"	v
debug_sema	semantic.c	/^bool debug_sema = false;$/;"	v
eleTypeName	semantic.h	/^    char* eleTypeName;      \/\/ type name of element$/;"	m	struct:ARRAY_INFO
false	parseTree.h	/^    true = 1, false = 0$/;"	e	enum:Boolean
fields	semantic.h	/^    struct VAR_INFO** fields;         \/\/ fields of struct (var type and var name)$/;"	m	struct:STRUCT_INFO	typeref:struct:STRUCT_INFO::VAR_INFO
first_line	parseTree.h	/^    int first_line;         \/\/ first line number of current node$/;"	m	struct:TreeNode
funcCount	intercodegen.c	/^int funcCount = 0;      \/\/ fx$/;"	v
func_info	semantic.h	/^    struct FUNC_INFO* func_info;$/;"	m	union:TYPE_DETAIL	typeref:struct:TYPE_DETAIL::FUNC_INFO
getFormatStr	intercodegen.c	/^char* getFormatStr(const char* prefix, int num){$/;"	f
getInterCodeVarName	intercodegen.c	/^char* getInterCodeVarName(char* varName){$/;"	f
getSourceCodeVarName	intercodegen.c	/^char* getSourceCodeVarName(char* interCodeVarName){$/;"	f
getSymbolInfo	semantic.c	/^VAR_INFO* getSymbolInfo(char* varName){$/;"	f
getTypeInfo	semantic.c	/^TYPE_INFO* getTypeInfo(char* typeName){$/;"	f
hash_table	semantic.c	/^bool hash_table[HASH_TABLE_SIZE];$/;"	v
hash_table	semantic.h	/^    bool hash_table[HASH_TABLE_SIZE];$/;"	m	struct:HASH_TABLE_NODE
ifArray	semantic.h	/^    bool ifArray;   \/\/ array->true, non-array->false$/;"	m	struct:VAR_INFO
if_leaf	parseTree.h	/^    bool if_leaf;           \/\/ note if current node is leaf node$/;"	m	struct:TreeNode
info	semantic.h	/^    struct TYPE_INFO* info;$/;"	m	struct:TYPE_LIST_NODE	typeref:struct:TYPE_LIST_NODE::TYPE_INFO
info	semantic.h	/^    struct VAR_INFO* info;$/;"	m	struct:SYMBOL_LIST_NODE	typeref:struct:SYMBOL_LIST_NODE::VAR_INFO
initHashTable	semantic.c	/^void initHashTable(){$/;"	f
initReadWriteFunction	semantic.c	/^void initReadWriteFunction(){$/;"	f
insertInterCode	intercodegen.c	/^void insertInterCode(InterCode* interCode){$/;"	f
insertIntoArgList	intercodegen.c	/^void insertIntoArgList(Operand* operand){$/;"	f
insertIntoHashTable	semantic.c	/^void insertIntoHashTable(char* str){$/;"	f
insertIntoHashTableInNode	semantic.c	/^void insertIntoHashTableInNode(char* str, HASH_NODE** node){$/;"	f
insertLabelInterCode	intercodegen.c	/^void insertLabelInterCode(Operand* label){$/;"	f
insertNameMap	intercodegen.c	/^void insertNameMap(char* varName, char* interCodeVarName){$/;"	f
insertSymbol	semantic.c	/^void insertSymbol(VAR_INFO* var_info){$/;"	f
insertType	semantic.c	/^void insertType(TYPE_INFO* typeInfo, const char* typeCategory){$/;"	f
interCode	intercodegen.h	/^    InterCode* interCode;$/;"	m	struct:InterCodeNode
interCodeListHead	intercodegen.c	/^InterCodeNode* interCodeListHead = NULL;$/;"	v
interCodeVarName	intercodegen.h	/^    char* interCodeVarName;$/;"	m	struct:NameMap
labelCount	intercodegen.c	/^int labelCount = 0;     \/\/ labelx$/;"	v
memDec	intercodegen.h	/^        }memDec;$/;"	m	union:InterCode::__anon1	typeref:struct:InterCode::__anon1::__anon6
n_children	parseTree.h	/^    int n_children;         \/\/ number of children node$/;"	m	struct:TreeNode
n_children	semantic.h	/^    int n_children;$/;"	m	struct:HASH_TABLE_NODE
n_fields	semantic.h	/^    int n_fields;   \/\/ num of fields$/;"	m	struct:STRUCT_INFO
n_operand	intercodegen.h	/^    int n_operand;          \/\/ number of operands$/;"	m	struct:InterCode
n_params	semantic.h	/^    int n_params;       \/\/ num of parameters$/;"	m	struct:FUNC_INFO
name	parseTree.h	/^    char* name;             \/\/ name of node, e.g. ID, LP, Stmt$/;"	m	struct:TreeNode
nameMap	intercodegen.h	/^    NameMap nameMap;$/;"	m	struct:NameMapNode
nameMapListHead	intercodegen.c	/^NameMapNode* nameMapListHead = NULL;$/;"	v
next	intercodegen.h	/^    struct ArgListNode* next;$/;"	m	struct:ArgListNode	typeref:struct:ArgListNode::ArgListNode
next	intercodegen.h	/^    struct InterCodeNode* next;$/;"	m	struct:InterCodeNode	typeref:struct:InterCodeNode::InterCodeNode
next	intercodegen.h	/^    struct NameMapNode* next;$/;"	m	struct:NameMapNode	typeref:struct:NameMapNode::NameMapNode
next	semantic.h	/^    struct SYMBOL_LIST_NODE* next;$/;"	m	struct:SYMBOL_LIST_NODE	typeref:struct:SYMBOL_LIST_NODE::SYMBOL_LIST_NODE
next	semantic.h	/^    struct TYPE_LIST_NODE* next;$/;"	m	struct:TYPE_LIST_NODE	typeref:struct:TYPE_LIST_NODE::TYPE_LIST_NODE
o1	intercodegen.h	/^        }o1;$/;"	m	union:InterCode::__anon1	typeref:struct:InterCode::__anon1::__anon2
o2	intercodegen.h	/^        }o2;$/;"	m	union:InterCode::__anon1	typeref:struct:InterCode::__anon1::__anon3
o3	intercodegen.h	/^        }o3;$/;"	m	union:InterCode::__anon1	typeref:struct:InterCode::__anon1::__anon4
op1	intercodegen.h	/^            Operand* op1;    \/\/ owner of this declared space$/;"	m	struct:InterCode::__anon1::__anon6
op1	intercodegen.h	/^            Operand* op1;$/;"	m	struct:InterCode::__anon1::__anon2
op1	intercodegen.h	/^            Operand* op1;$/;"	m	struct:InterCode::__anon1::__anon3
op1	intercodegen.h	/^            Operand* op1;$/;"	m	struct:InterCode::__anon1::__anon4
op1	intercodegen.h	/^            Operand* op1;$/;"	m	struct:InterCode::__anon1::__anon5
op2	intercodegen.h	/^            Operand* op2;$/;"	m	struct:InterCode::__anon1::__anon3
op2	intercodegen.h	/^            Operand* op2;$/;"	m	struct:InterCode::__anon1::__anon4
op2	intercodegen.h	/^            Operand* op2;$/;"	m	struct:InterCode::__anon1::__anon5
op3	intercodegen.h	/^            Operand* op3;$/;"	m	struct:InterCode::__anon1::__anon4
op3	intercodegen.h	/^            Operand* op3;$/;"	m	struct:InterCode::__anon1::__anon5
operand	intercodegen.h	/^    Operand* operand;$/;"	m	struct:ArgListNode
ops	intercodegen.h	/^    }ops;$/;"	m	struct:InterCode	typeref:union:InterCode::__anon1
paramCount	intercodegen.c	/^int paramCount = 0;     \/\/ px$/;"	v
params	semantic.h	/^    struct VAR_INFO** params;     \/\/ parameters of function (var type and var name)$/;"	m	struct:FUNC_INFO	typeref:struct:FUNC_INFO::VAR_INFO
parent	parseTree.h	/^    struct TreeNode* parent;           \/\/ parent of current node$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode
parent	semantic.h	/^    struct HASH_TABLE_NODE* parent;$/;"	m	struct:HASH_TABLE_NODE	typeref:struct:HASH_TABLE_NODE::HASH_TABLE_NODE
preOrderTraverse	parseTree.c	/^void preOrderTraverse(Node* root, int depth){$/;"	f
printErrorTypeA	parseTree.c	/^void printErrorTypeA(char* msg, int lineno){$/;"	f
printErrorTypeB	parseTree.c	/^void printErrorTypeB(char* msg, int lineno){$/;"	f
propertyValue	parseTree.h	/^    char* propertyValue;    \/\/ property value of node, can be empty, e.g. myVar, int, float$/;"	m	struct:TreeNode
relop	intercodegen.h	/^            char* relop;$/;"	m	struct:InterCode::__anon1::__anon5
returnTypeName	semantic.h	/^    char* returnTypeName;   \/\/ type name of return value ("void" for void)$/;"	m	struct:FUNC_INFO
root_hash_node	semantic.c	/^HASH_NODE* root_hash_node = NULL;$/;"	v
searchHashTable	semantic.c	/^bool searchHashTable(char* str){$/;"	f
searchHashTableInNode	semantic.c	/^HASH_NODE* searchHashTableInNode(char* str, HASH_NODE* node){$/;"	f
showAllInterCode	intercodegen.c	/^void showAllInterCode(){$/;"	f
showAllNameMap	intercodegen.c	/^void showAllNameMap(){$/;"	f
showSymbolList	semantic.c	/^void showSymbolList(){$/;"	f
showTypeList	semantic.c	/^void showTypeList(){$/;"	f
size	intercodegen.h	/^            int size;$/;"	m	struct:InterCode::__anon1::__anon6
size	semantic.h	/^    int size;               \/\/ size of array$/;"	m	struct:ARRAY_INFO
status	semantic.h	/^    bool status;$/;"	m	struct:HASH_ELE
str	semantic.h	/^    char* str;$/;"	m	struct:HASH_ELE
struct_info	semantic.h	/^    struct STRUCT_INFO* struct_info;$/;"	m	union:TYPE_DETAIL	typeref:struct:TYPE_DETAIL::STRUCT_INFO
symbol_list_head	semantic.c	/^SYMBOL_NODE* symbol_list_head = NULL;$/;"	v
tempCount	intercodegen.c	/^int tempCount = 0;      \/\/ tx$/;"	v
translate_Args	intercodegen.c	/^void translate_Args(Node* args){$/;"	f
translate_Cond	intercodegen.c	/^void translate_Cond(Node* exp, Operand* label_true, Operand* label_false){$/;"	f
translate_Dec	intercodegen.c	/^void translate_Dec(Node* dec, char* varName){$/;"	f
translate_Exp	intercodegen.c	/^void translate_Exp(Node* exp, Operand* placeOperand){$/;"	f
translate_FunDec	intercodegen.c	/^void translate_FunDec(Node* fundec){$/;"	f
translate_FunDecParam	intercodegen.c	/^void translate_FunDecParam(char* paramName){$/;"	f
translate_Stmt	intercodegen.c	/^void translate_Stmt(Node* stmt){$/;"	f
true	parseTree.h	/^    true = 1, false = 0$/;"	e	enum:Boolean
type	intercodegen.h	/^    IRType type;            \/\/ type of IR$/;"	m	struct:InterCode
typeCategory	semantic.h	/^    char* typeCategory;     \/\/ "array", "function" or "struct"$/;"	m	struct:TYPE_INFO
typeDetail	semantic.h	/^    union TYPE_DETAIL* typeDetail;$/;"	m	struct:TYPE_INFO	typeref:union:TYPE_INFO::TYPE_DETAIL
typeName	semantic.h	/^    char* typeName;$/;"	m	struct:TYPE_INFO
type_list_head	semantic.c	/^TYPE_NODE* type_list_head = NULL;$/;"	v
value	intercodegen.h	/^    char* value;$/;"	m	struct:Operand
varCount	intercodegen.c	/^int varCount = 0;       \/\/ vx$/;"	v
varName	intercodegen.h	/^    char* varName;$/;"	m	struct:NameMap
varName	semantic.h	/^    char* varName;$/;"	m	struct:VAR_INFO
varType	semantic.h	/^    char* varType;  \/\/ int->"int", float->"float", array->element type name, function->"function", stru->"struct"$/;"	m	struct:VAR_INFO
writeInterCode	intercodegen.c	/^void writeInterCode(char* fileName){$/;"	f
